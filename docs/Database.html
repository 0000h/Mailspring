---
layout: docs
title: Accessing the Database
edit_url: "https://github.com/nylas/N1/blob/a2c697754ad692e6a54629ffd93883dda79b0d78/docs/Database.md"
---
<p>N1 is built on top of a custom database layer modeled after ActiveRecord. For many parts of the application, the database is the source of truth. Data is retrieved from the API, written to the database, and changes to the database trigger Stores and components to refresh their contents. The illustration below shows this flow of data:</p>
<p><img src="./images/database-flow.png"></p>
<p>The Database connection is managed by the <a href='databasestore.html'>DatabaseStore</a>, a singleton object that exists in every window. All Database requests are asynchronous. Queries are forwarded to the application&#39;s <code>Browser</code> process via IPC and run in SQLite.</p>
<h2 id="declaring-models">Declaring Models</h2>
<p>In N1, Models are thin wrappers around data with a particular schema. Each <a href='model.html'>Model</a> class declares a set of attributes that define the object&#39;s data. For example:</p>
<pre><code class="lang-coffee"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">Model</span>
</span>
  <span class="hljs-annotation">@attributes</span>:
    <span class="hljs-symbol">'i</span>d': <span class="hljs-type">Attributes</span>.<span class="hljs-type">String</span>
      queryable: <span class="hljs-literal">true</span>
      modelKey: <span class="hljs-symbol">'i</span>d'

    <span class="hljs-symbol">'objec</span>t': <span class="hljs-type">Attributes</span>.<span class="hljs-type">String</span>
      modelKey: <span class="hljs-symbol">'objec</span>t'

    <span class="hljs-symbol">'namespaceI</span>d': <span class="hljs-type">Attributes</span>.<span class="hljs-type">String</span>
      queryable: <span class="hljs-literal">true</span>
      modelKey: <span class="hljs-symbol">'namespaceI</span>d'
      jsonKey: <span class="hljs-symbol">'namespace_i</span>d'

    <span class="hljs-symbol">'bod</span>y': <span class="hljs-type">Attributes</span>.<span class="hljs-type">JoinedData</span>
      modelTable: <span class="hljs-symbol">'MessageBod</span>y'
      modelKey: <span class="hljs-symbol">'bod</span>y'

    <span class="hljs-symbol">'file</span>s': <span class="hljs-type">Attributes</span>.<span class="hljs-type">Collection</span>
      modelKey: <span class="hljs-symbol">'file</span>s'
      itemClass: <span class="hljs-type">File</span>

    <span class="hljs-symbol">'unrea</span>d': <span class="hljs-type">Attributes</span>.<span class="hljs-type">Boolean</span>
      queryable: <span class="hljs-literal">true</span>
      modelKey: <span class="hljs-symbol">'unrea</span>d'
</code></pre>
<p>When models are inflated from JSON using <code>fromJSON</code> or converted to JSON using <code>toJSON</code>, only the attributes declared on the model are copied. The <code>modelKey</code> and <code>jsonKey</code> options allow you to specify where a particular key should be found. Attributes are also coerced to the proper types: String attributes will always be strings, Boolean attributes will always be <code>true</code> or <code>false</code>, etc. <code>null</code> is a valid value for all types.</p>
<p>The <a href='databasestore.html'>DatabaseStore</a> automatically maintains cache tables for storing Model objects. By default, models are stored in the cache as JSON blobs and basic attributes are not queryable. When the <code>queryable</code> option is specified on an attribute, it is given a separate column and index in the SQLite table for the model, and you can construct queries using the attribute:</p>
<pre><code class="lang-coffee">Thread<span class="hljs-class">.attributes</span><span class="hljs-class">.namespaceId</span><span class="hljs-class">.equals</span>(<span class="hljs-string">"123"</span>)
<span class="hljs-comment">// where namespace_id = '123'</span>

Thread<span class="hljs-class">.attributes</span><span class="hljs-class">.lastMessageTimestamp</span><span class="hljs-class">.greaterThan</span>(<span class="hljs-number">123</span>)
<span class="hljs-comment">// where last_message_timestamp &gt; 123</span>

Thread<span class="hljs-class">.attributes</span><span class="hljs-class">.lastMessageTimestamp</span><span class="hljs-class">.descending</span>()
<span class="hljs-comment">// order by last_message_timestamp DESC</span>
</code></pre>
<h2 id="retrieving-models">Retrieving Models</h2>
<p>You can make queries for models stored in SQLite using a <a href='https://github.com/petkaantonov/bluebird/blob/master/API.md'>Promise</a>-based ActiveRecord-style syntax. There is no way to make raw SQL queries against the local data store.</p>
<pre><code class="lang-coffee">DatabaseStore.find<span class="hljs-function"><span class="hljs-params">(Thread, <span class="hljs-string">'123'</span>)</span>.<span class="hljs-title">then</span> <span class="hljs-params">(thread)</span> -&gt;</span>
    <span class="hljs-comment"># thread is a thread object</span>

DatabaseStore.findBy<span class="hljs-function"><span class="hljs-params">(Thread, {subject: <span class="hljs-string">'Hello World'</span>})</span>.<span class="hljs-title">then</span> <span class="hljs-params">(thread)</span> -&gt;</span>
    <span class="hljs-comment"># find a single thread by subject</span>

DatabaseStore.findAll<span class="hljs-function"><span class="hljs-params">(Thread)</span>.<span class="hljs-title">where</span><span class="hljs-params">([Thread.attributes.tags.contains(<span class="hljs-string">'inbox'</span>)])</span>.<span class="hljs-title">then</span> <span class="hljs-params">(threads)</span> -&gt;</span>
    <span class="hljs-comment"># find threads with the inbox tag</span>

DatabaseStore.count<span class="hljs-function"><span class="hljs-params">(Thread)</span>.<span class="hljs-title">where</span><span class="hljs-params">([Thread.attributes.lastMessageTimestamp.greaterThan(<span class="hljs-number">120315123</span>)])</span>.<span class="hljs-title">then</span> <span class="hljs-params">(results)</span> -&gt;</span>
    <span class="hljs-comment"># count threads where last message received since 120315123.</span>
</code></pre>
<h2 id="retrieving-pages-of-models">Retrieving Pages of Models</h2>
<p>If you need to paginate through a view of data, you should use a <code>DatabaseView</code>. Database views can be configured with a sort order and a set of where clauses. After the view is configured, it maintains a cache of models in memory in a highly efficient manner and makes it easy to implement pagination. <code>DatabaseView</code> also performs deep inspection of it&#39;s cache when models are changed and can avoid costly SQL queries.</p>
<h2 id="saving-and-updating-models">Saving and Updating Models</h2>
<p>The <a href='databasestore.html'>DatabaseStore</a> exposes two methods for creating and updating models: <code>persistModel</code> and <code>persistModels</code>. When you call <code>persistModel</code>, queries are automatically executed to update the object in the cache and the <a href='databasestore.html'>DatabaseStore</a> triggers, broadcasting an update to the rest of the application so that views dependent on these kind of models can refresh.</p>
<p>When possible, you should accumulate the objects you want to save and call <code>persistModels</code>. The <a href='databasestore.html'>DatabaseStore</a> will generate batch insert statements, and a single notification will be broadcast throughout the application. Since saving objects can result in objects being re-fetched by many stores and components, you should be mindful of database insertions.</p>
<h2 id="saving-drafts">Saving Drafts</h2>
<p>Drafts in N1 presented us with a unique challenge. The same draft may be edited rapidly by unrelated parts of the application, causing race scenarios. (For example, when the user is typing and attachments finish uploading at the same time.) This problem could be solved by object locking, but we chose to marshall draft changes through a central DraftStore that debounces database queries and adds other helpful features. See the <a href='draftstore.html'>DraftStore</a> documentation for more information.</p>
<h2 id="removing-models">Removing Models</h2>
<p>The <a href='databasestore.html'>DatabaseStore</a> exposes a single method, <code>unpersistModel</code>, that allows you to purge an object from the cache. You cannot remove a model by ID alone - you must load it first.</p>
<h4 id="advanced-model-attributes">Advanced Model Attributes</h4>
<h5 id="attribute-joineddata">Attribute.JoinedData</h5>
<p>Joined Data attributes allow you to store certain attributes of an object in a separate table in the database. We use this attribute type for Message bodies. Storing message bodies, which can be very large, in a separate table allows us to make queries on message metadata extremely fast, and inflate Message objects without their bodies to build the thread list.</p>
<p>When building a <a href='modelquery.html'>ModelQuery</a> on a model with a {JoinedDataAttribute}, you need to call <code>include</code> to explicitly load the joined data attribute. The query builder will automatically perform a <code>LEFT OUTER JOIN</code> with the secondary table to retrieve the attribute:</p>
<pre><code class="lang-coffee">DatabaseStore.<span class="hljs-function"><span class="hljs-title">find</span><span class="hljs-params">(Message, <span class="hljs-string">'123'</span>)</span></span><span class="hljs-class">.then</span> (message) -&gt;
    <span class="hljs-comment">// message.body is undefined</span>

DatabaseStore.<span class="hljs-function"><span class="hljs-title">find</span><span class="hljs-params">(Message, <span class="hljs-string">'123'</span>)</span></span>.<span class="hljs-function"><span class="hljs-title">include</span><span class="hljs-params">(Message.attributes.body)</span></span><span class="hljs-class">.then</span> (message) -&gt;
    <span class="hljs-comment">// message.body is defined</span>
</code></pre>
<p>When you call <code>persistModel</code>, JoinedData attributes are automatically written to the secondary table.</p>
<p>JoinedData attributes cannot be <code>queryable</code>.</p>
<h5 id="attribute-collection">Attribute.Collection</h5>
<p>Collection attributes provide basic support for one-to-many relationships. For example, <a href='thread.html'>Thread</a>s in N1 have a collection of {Tag}s.</p>
<p>When Collection attributes are marked as <code>queryable</code>, the <a href='databasestore.html'>DatabaseStore</a> automatically creates a join table and maintains it as you create, save, and delete models. When you call <code>persistModel</code>, entries are added to the join table associating the ID of the model with the IDs of models in the collection.</p>
<p>Collection attributes have an additional clause builder, <code>contains</code>:</p>
<pre><code class="lang-coffee">DatabaseStore.<span class="hljs-function"><span class="hljs-title">findAll</span><span class="hljs-params">(Thread)</span></span>.<span class="hljs-function"><span class="hljs-title">where</span><span class="hljs-params">([Thread.attributes.tags.contains(<span class="hljs-string">'inbox'</span>)</span></span>])
</code></pre>
<p>This is equivalent to writing the following SQL:</p>
<pre><code class="lang-sql">SELECT <span class="hljs-escape">`T</span>hread<span class="hljs-escape">`.</span><span class="hljs-escape">`d</span>ata<span class="hljs-escape">` </span>FROM <span class="hljs-escape">`T</span>hread<span class="hljs-escape">` </span>INNER JOIN <span class="hljs-escape">`T</span>hread-Tag<span class="hljs-escape">` </span>AS <span class="hljs-escape">`M</span>1<span class="hljs-escape">` </span>ON <span class="hljs-escape">`M</span>1<span class="hljs-escape">`.</span><span class="hljs-escape">`i</span>d<span class="hljs-escape">` </span>= <span class="hljs-escape">`T</span>hread<span class="hljs-escape">`.</span><span class="hljs-escape">`i</span>d<span class="hljs-escape">` </span>WHERE <span class="hljs-escape">`M</span>1<span class="hljs-escape">`.</span><span class="hljs-escape">`v</span>alue<span class="hljs-escape">` </span>= 'inbox' ORDER BY <span class="hljs-escape">`T</span>hread<span class="hljs-escape">`.</span><span class="hljs-escape">`l</span>ast_message_timestamp<span class="hljs-escape">` </span>DESC
</code></pre>
<h4 id="listening-for-changes">Listening for Changes</h4>
<p>For many parts of the application, the Database is the source of truth. Funneling changes through the database ensures that they are available to the entire application. Basing your packages on the Database, and listening to it for changes, ensures that your views never fall out of sync.</p>
<p>Within Reflux Stores, you can listen to the <a href='databasestore.html'>DatabaseStore</a> using the <code>listenTo</code> helper method:</p>
<pre><code class="lang-coffee"><span class="hljs-variable">@listenTo</span>(DatabaseStore, <span class="hljs-variable">@_onDataChanged</span>)
</code></pre>
<p>Within generic code, you can listen to the <a href='databasestore.html'>DatabaseStore</a> using this syntax:</p>
<pre><code class="lang-coffee"><span class="hljs-variable">@unlisten</span> = DatabaseStore.<span class="hljs-function">listen</span>(<span class="hljs-variable">@_onDataChanged</span>, @)
</code></pre>
<p>When a model is persisted or unpersisted from the database, your listener method will fire. It&#39;s very important to inspect the change payload before making queries to refresh your data. The change payload is a simple object with the following keys:</p>
<pre><code>{
    <span class="hljs-string">"objectClass"</span>: <span class="hljs-comment">// string: the name of the class that was changed. ie: "Thread"</span>
    <span class="hljs-string">"objects"</span>: <span class="hljs-comment">// array: the objects that were persisted or removed</span>
}
</code></pre><h2 id="but-why-can-t-i-">But why can&#39;t I...?</h2>
<p>N1 exposes a minimal Database API that exposes high-level methods for saving and retrieving objects. The API was designed with several goals in mind, which will help us create a healthy ecosystem of third-party packages:</p>
<ul>
<li><p>Package code should not be tightly coupled to SQLite</p>
</li>
<li><p>Queries should be composed in a way that makes invalid queries impossible</p>
</li>
<li><p>All changes to the local database must be observable</p>
</li>
</ul>
